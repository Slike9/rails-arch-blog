---
layout: post
title:  "Рефакторинг проекта: выделяем слой доступа к данным"
date:   2018-03-28 22:09:00 +0400
categories:
---

Раннее, в статье [Рефакторинг проекта: выделяем Service
Layer][extract-service-layer], рассматривалось выделение бизнес-логики из слоя
представления, из контроллеров, в свой слой бизнес-логики. Между тем в [слоистой
архитектуре][layered-architecture] есть третий слой, которого до сего момента не
касались - _слой доступа к данным_ (_Data Access_) или _слой источника данных_
(_Data Source_).

### Для чего эта статья

Рассматривается выделение слоя доступа к данным в приложении.

## Слой доступа к данным

Любое серьёзное приложение имеет дело с данными, которые поступают из вне. В
общем случае приложение взаимодействует, обменивается информацией с внешним
миром для решения своих задач. Взаимодействовать приложение может с файловыми
системами, с базами данных (БД) различных типов, прочими программами и
сервисами.

Подобная логика взаимодействия может быть довольно сложной и запутанной, часто
имеет дело с такими низкоуровневыми вещами как TCP-сокеты, HTTP-протокол и
прочее. Переплетение же подобного кода с бизнес-логикой, часто без того сложной,
крайне нежелательно.

Логику работы с внешними данными в [слоистой архитектуре][layered-architecture]
выносят в специальный слой - _слой доступа к данным_ (_Data Access_). Остальному
приложению данный слой предоставляет удобный, высокоуровневый интерфейс к
внешним данным и сервисам - слой содержит адаптеры к внешним источникам данных,
абстрагируя последние. Это позволяет бизнес-логике запрашивать данные, не
заботясь о том, как и откуда они будут получены.

Выделение этого слоя даёт и другие преимущества: возможность подмены
реальных источников данных при тестировании и при смене провайдера данных.

Но ещё раз повторюсь, для меня выделение данного слоя, как и других слоёв, важно
само по себе. Это делает систему структурированной, понятной, изучаемой, а
значит, более лёгкой в поддержке. Каждый слой вполне самостоятелен, это
позволяет концентрироваться на отдельной, сравнительно небольшой части
приложения, не заботясь о деталях всего остального. Так, если стоит задача
реализовать отправку SMS через специальный сервис (SMS-шлюз), нам не нужно
знать, кто, при нажатии какой кнопки, при каком условии будет эти сообщения
отправлять. В рамках слоя данных важен лишь протокол работы с SMS-шлюзом и API,
по которому слой бизнес-логики будет запрашивать отправку сообщений.

## Доступ к БД

Основным источником данных в Rails-приложении является конечно БД.
Взаимодействие с БД реализовано в самом фреймворке библиотекой [activerecord].
Библиотека помимо прочего реализует типовое решение [Active Record].

Паттерн [Active Record] - способ организации доступа к данным для бизнес-логики,
представленной в свою очередь типовым решением [Domain Model]. Каждой модели,
сохраняемой в БД, взаимно однозначно соответствует таблица БД. Каждый объект
модели представляет определённую запись из соответствующей таблицы. При этом
объект модели содержит как логику домена, так и логику загрузки/сохранения
соответствующей записи базы, то есть он сам умеет себя загружать и сохранять.

Другой известный способ работы с БД - [Data Mapper]. Отображение объектной
модели на БД в этом случае может быть произвольным, от чего модель предметной
области не зависит от схемы базы. Иными словами, логическая модель не зависит от
физической.

В нашем приложении для доступа к БД используется стандартное средство -
вышеупомянутая библиотека [activerecord].

Модели в Rails располагаются в папке `app/models/`. В нашем случае есть модель
`Content`.

{% highlight ruby %}
# app/models/content.rb

class Content < ApplicationRecord
  validates :name, presence: true
  validates :uid, presence: true, uniqueness: true
end
{% endhighlight %}

Модели `Content` по соглашениям Rails соответствует таблица в `contents`.

Можно отметить, библиотека [activerecord] не разделяет явно слои бизнес-логики и
доступа к данным. Пожалуй, это характерно для паттерна [Active Record] вообще.

## Доступ к внешним сервисам

У нас есть ещё один источник данных - платформа предоставления контента
`ServicesPlatform`. Это внешний сервис, с которым наше приложение синхронизирует
контент. Также от него получаем информацию о пользователях и их покупках.

Для доступа к сервису через его API у нас есть специальная библиотека
`ServicesPlatformApi`.

Пример вызова библиотеки для получения покупок пользователя:
{% highlight ruby %}
ServicesPlatformApi.purchases(current_user.uid)
{% endhighlight %}

Однако данная библиотека является обобщённой, предоставляет сравнительно простой
способ доступа к сервису для Ruby-приложений, от того с точки зрения
бизнес-логики оказывается низкоуровневой. К примеру, покупки в вышеописанном
примере возвращаются в виде массива хэшей.

Как упоминалось выше, задача слоя доступа к данным как раз заключается в том,
чтобы предоставить удобный, высокоуровневый интерфейс к данным. Так в
бизнес-логике предпочтительнее получать покупки в виде объектов специального
типа `Purchase`, а не хэшей.

Покупки и пользователи приходят из внешнего сервиса, а не из БД. Модели их
реализованы не как Active Record, а в виде PORO с применением библиотеки
[virtus].

Пример модели `Purchase`:

{% highlight ruby %}
# app/models/purchase.rb

class Purchase
 include Virtus.model

 attribute :uid, String
 attribute :user_uid, String
 attribute :content_uid, String
end
{% endhighlight %}

Подобные модели также располагаются в папке `app/models/`.

Адаптеры источников данных, которые и представляют слой доступа к данным, у нас
располагаются в папке `app/data_sources/` в виде модулей с методами:

{% highlight ruby %}
# app/data_sources/platform/purchases_source.rb
module Platform::PurchasesSource
  class << self
    def get_purchases(user_uid)
      ServicesPlatformApi.purchases(user_uid)
                          .map { |attrs| Purchase.new(attrs) }
    end
  end
end
{% endhighlight %}

{% highlight ruby %}
# app/data_sources/platform/users_source.rb
module Platform::UsersSource
  class << self
    def get_user(uid)
      user_attrs = ServicesPlatformApi.get_user(uid)
      User.new(user_attrs)
    end
  end
end
{% endhighlight %}

После выделения слоя данных метод `ContentService.purchases` из [предыдущей
статьи][extract-service-layer] будет следующим:

{% highlight ruby %}
# app/services/content_service.rb

module ContentService
  class << self
    # ...

    # Get user purchases.
    # @param [User] user
    # @return [Array<Purchase>]
    def purchases(user)
      return [] if user.guest?

      Platform::PurchasesSource.user_purchases(user.uid)
    end

    # ...
  end
end
{% endhighlight %}

## Заключение

Рассмотрели выделение в проекте слоя доступа к данным на примере кода из
предыдущих статей. Перед этим описали, что данный слой собой представляет, чем
он может быть полезен.

Несомненно, приведённые примеры не отличались какой-нибудь сложностью. Так
адаптеры содержали минимум логики - вызов методов API сервиса и конвертацию
данных. Вероятно, это не позволяет ярко увидеть все преимущества подхода. В
реальном проекте слой доступа к данным без работы точно не останется, а
упрощение бизнес-логики за счёт выделения слоя данных будет более впечатляющим.

[extract-service-layer]: {{site.baseurl}}{% post_url 2018-03-06-extract-service-layer %}
[layered-architecture]: https://martinfowler.com/bliki/PresentationDomainDataLayering.html
[Service Layer]: https://martinfowler.com/eaaCatalog/serviceLayer.html
[Active Record]: https://www.martinfowler.com/eaaCatalog/activeRecord.html
[Data Mapper]: https://martinfowler.com/eaaCatalog/dataMapper.html
[Domain Model]: https://martinfowler.com/eaaCatalog/domainModel.html
[activerecord]: https://github.com/rails/rails/tree/master/activerecord
[virtus]: https://github.com/solnic/virtus

[modeline]: # ( vim: set tw=80 spell spl=ru,en: )
