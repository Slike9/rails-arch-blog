---
layout: post
title:  "Новый проект, застарелые проблемы"
date:   2018-02-22 12:29:39 +0400
categories:
---

Вот почти год я работаю на текущем проекте. К моменту моего прихода проекту
было где-то полтора года. Вся функциональность, можно сказать, была тогда
сделана, приложение работало в продакшене. Таким образом, основной моей работой
была поддержка: фикс багов, реализация небольших фич. Казалось бы, дело скучное
и нехитрое. Однако уже в самом начале довелось столкнуться с массой проблем:
терялись логги, само логгирование не было нормально настроено, часть исключений
не отсылалась в систему регистрации ошибок. Необходимо было навести
определённый порядок. Но это не всё. Кое-что заставило меня пересмотреть
структуру проекта, архитектуру.

### Для чего эта статья

Это вводная статья, открывает серию из нескольких частей, повествующих о
проведённом рефакторинге. Даётся краткое описание проекта. Приводится причина,
по которой возникла необходимость изменений, излагается личная мотивация,
раскрывается суть проблемы.

### Для чего эта серия статей

В серии статей хотел бы описать опыт рефакторинга одного проекта. Также
хотелось бы поделиться личным взглядом на структуру Rails-проекта.

## О проекте

Проект, над которым я работаю - относительно простое приложение на Rails
и React. Это web-клиент к платформе предоставления некого контента, позволяет
пользователям получать доступ к контенту через web-браузер. Всё, что
описывается далее, относится к бэкенду на Rails. Бэкенд состоит из традиционных
web-части, api, админки, не говоря о sidekiq-джобах, rake-тасках и прочего.

## Проблема

Как уже писал, значительную часть времени приходилось заниматься исправлением
ошибок. Часто при отладке и расследовании сбоев нужно было воспроизводить
сценарии работы приложения в Rails-консоли. Но этот процесс оказался достаточно
хлопотным. Нельзя было просто взять сценарий из интересующего экшена контроллера
и запустить его в консоли. Значительная часть логики находилась в контроллерах и
концернах, поэтому сначала надо было перенести нужную часть этой логики в
консоль, сделать её доступной. При этом код логики был сильно переплетён между
собой, отсюда наличие обширных транзитивных зависимостей делало процесс переноса
кода далеко не самым весёлым занятием.

Конечно, можно было не заниматься копированием, а создавать экземпляр нужного
контроллера и выполнять сценарий в его контексте. Но здесь всё равно остаётся
прелюдия. При этом простого `MyController.new` не всегда бывает достаточно и
требуется более тщательная инициализация, например, для правильной работы
методов `params`, `headers` или `session`. В общем, способ тоже далёк от
идеального, о каком-то удобстве говорить не приходится. Хотелось бы вообще
забыть про контроллеры и сосредоточиться на сути - на сценарии, на логике.

## Идея решения

Сильная связанность бизнес-логики с контроллерами - это основная проблема.
Требуется выделить логику и сделать её легкодоступной из консоли.

[Слоистая архитектура][layered-architecture] предлагает способ разделения
приложения на три основные части: представление, бизнес-логику и доступ к данным.
Дополнительно в бизнес-логике выделяют внешний подслой [Service Layer].

В нашем случае логику из контроллеров (слой представления) следует вынести в
свой слой - слой бизнес-логики. По большей части здесь будет прикладная логика,
она будет выноситься в [Service Layer].

Неплохо бы также привести в соответствие всю архитектуру - явно выделить три
слоя. Хорошо структурированная система легче для изучения, восприятия, развития,
ибо нет нужды постоянно держать в голове её всю со всеми её аспектами. Можно
концентрироваться на интересующем компоненте, который при этом однороден и
относительно независим. Так появляется возможность концентрироваться на меньшей
области приложения - нужном слое, абстрагировавшись от остального приложения, во
всяком случае от деталей других слоёв, что значительно облегчает разработку.

## Заключение

Трудность выполнения сценариев в Rails-консоли на самом деле являлась далеко не
самым критичным следствием проблем в проекте. Это было лишь неудобство, но оно
сильно раздражало и таким образом явилось моей мотивацией для рефакторинга.

Проблема же гораздо глубже, она касается всего проекта, его качества.
Последствия плохого кода серьёзны: низкая производительность, высокая
вероятность внесения ошибок, раздражительность разработчиков.

Для решения проблемы с организацией кода было принято разделить приложение на
слои, применив [Presentation-Domain-Data Layering][layered-architecture] и
[Service Layer].

В последующих статьях подробно опишу этапы намеченного рефакторинга. Начнём с
[выделения Service Layer][extract-service-layer].

[extract-service-layer]: {{site.baseurl}}{% post_url 2018-03-06-extract-service-layer %}
[layered-architecture]: https://martinfowler.com/bliki/PresentationDomainDataLayering.html
[Service Layer]: https://martinfowler.com/eaaCatalog/serviceLayer.html

[modeline]: # ( vim: set tw=80 spell spl=ru,en: )
